给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。
```
示例 1 :

输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
```
请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
示例 2 :
```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
注意：
```
s.length 在1到50,000之间。
s 只包含“0”或“1”字符。


#思路
解法：（这里给出的是官方的解法的翻译，还是很容易看懂的）

我们可以将字符串s转换为表示字符串中相同字符的连续块的长度的数组组。
例如，如果s =“110001111000000”，则groups = [2，3，4，6]。
对于形式为'0'* k +'1'* k或'1'* k +'0'* k的每个二进制字符串，此字符串的中间必须出现在两个group之间。 
我们尝试计算group[i]和group[i + 1]之间的有效二进制字符串的数量。
如果我们有group[i] = 2，group[i + 1] = 3，则表示“00111”或“11000”。
我们明确地可以使min（group[i]，group[i + 1]）在此字符串内有效的二进制字符串。因为这个字符串左边或右边的二进制数字必须在边界改变，所以我们的答案永远不会更大。

#code
```
class Solution {
    public int countBinarySubstrings(String s) {
        int[] sarry = new int[s.length()];
		int t =0;
		sarry[0] =1;
		for(int i = 0 ;i<s.length()-1;i++){
			if(s.charAt(i) != s.charAt(i+1)){
				sarry[++t]=1;
			}else{
				sarry[t]++;
			}
		}
		
		int num = 0;
		for(int j = 1 ;j<sarry.length;j++){
			num+=Math.min(sarry[j],sarry[j-1]);
		}
		return num;
        
    }
}
```
